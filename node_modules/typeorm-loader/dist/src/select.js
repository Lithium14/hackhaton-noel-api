"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var graphql_1 = require("graphql");
function parseLiteral(ast) {
    switch (ast.kind) {
        case graphql_1.Kind.STRING:
        case graphql_1.Kind.BOOLEAN:
            return ast.value;
        case graphql_1.Kind.INT:
        case graphql_1.Kind.FLOAT:
            return parseFloat(ast.value);
        case graphql_1.Kind.OBJECT:
            {
                var value_1 = Object.create(null);
                ast.fields.forEach(function (field) {
                    value_1[field.name.value] = parseLiteral(field.value);
                });
                return value_1;
            }
        case graphql_1.Kind.LIST:
            return ast.values.map(parseLiteral);
        default:
            return null;
    }
}
function getSelections(ast) {
    if (ast &&
        ast.selectionSet &&
        ast.selectionSet.selections &&
        ast.selectionSet.selections.length) {
        return ast.selectionSet.selections;
    }
    return [];
}
function isFragment(ast) {
    return ast.kind === 'InlineFragment' || ast.kind === 'FragmentSpread';
}
function getAST(ast, info) {
    if (ast.kind === 'FragmentSpread') {
        var fragmentName = ast.name.value;
        return info.fragments[fragmentName];
    }
    return ast;
}
function flattenAST(ast, info, obj) {
    if (obj === void 0) { obj = {}; }
    return getSelections(ast).reduce(function (flattened, n) {
        if (isFragment(n)) {
            flattened = flattenAST(getAST(n, info), info, flattened);
        }
        else {
            var node = n;
            var name = node.name.value;
            if (flattened[name]) {
                Object.assign(flattened[name].children, flattenAST(node, info, flattened[name].children));
            }
            else {
                flattened[name] = {
                    arguments: node.arguments ? node.arguments.map(function (_a) {
                        var name = _a.name, value = _a.value;
                        var _b;
                        return (_b = {}, _b[name.value] = parseLiteral(value), _b);
                    }).reduce(function (p, n) { return (__assign({}, p, n)); }, {}) : {},
                    children: flattenAST(node, info)
                };
            }
        }
        return flattened;
    }, obj);
}
function graphqlFields(info, obj) {
    if (obj === void 0) { obj = {}; }
    var fields = info.fieldNodes;
    return { children: fields.reduce(function (o, ast) { return flattenAST(ast, info, o); }, obj) };
}
exports.graphqlFields = graphqlFields;
function select(model, selection, connection, qb, alias, history) {
    var meta = connection.getMetadata(model);
    if (selection && selection.children) {
        var fields = meta.columns;
        fields
            .filter(function (field) {
            return field.propertyName in selection.children;
        }).forEach(function (field) { return qb = qb.addSelect(alias + "." + field.propertyName, alias + "_" + field.propertyName); });
        var relations = meta.relations;
        relations.forEach(function (relation) {
            if (relation.propertyName in selection.children) {
                var target = connection.getRepository(relation.target).target;
                var name = typeof target == 'string' ? target : target.name;
                var childAlias = alias + '_' + name;
                qb = qb.addFrom(name, childAlias);
                qb = qb.leftJoin(alias + '.' + relation.propertyName, name, childAlias);
                qb = select(target, selection.children[relation.propertyName], connection, qb, childAlias);
            }
        });
    }
    else if (selection === null) {
        history = history || new Set();
        var relations = meta.relations;
        relations.forEach(function (relation) {
            var childAlias = alias + "_" + relation.propertyName;
            // const target = relation.inverseEntityMetadata.target;
            // const name = typeof target == 'string' ? target : target.name;
            if (relation.inverseRelation) {
                if (history.has(relation.inverseRelation)) {
                    qb = qb.addSelect(alias);
                    return;
                }
                history.add(relation);
                qb = qb.addFrom(relation.inverseRelation.entityMetadata.targetName, relation.inverseEntityMetadata.targetName);
                qb = qb.leftJoin(alias + '.' + relation.propertyName, childAlias);
                qb = select(relation.inverseEntityMetadata.targetName, null, connection, qb, childAlias, history);
            }
            else {
                qb = qb.addSelect(relation.propertyName, childAlias);
            }
        });
    }
    return qb;
}
exports.select = select;
//# sourceMappingURL=select.js.map